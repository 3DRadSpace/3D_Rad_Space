using System;
using System.Collections.Generic;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;

namespace Lib3DRadSpace_DX
{
    /// <summary>
    /// Allows drawing of 3D objects. Practically a container for some Matrix structs.
    /// </summary>
    public class Camera : BaseGameObject
    {

        /// <summary>
        /// Camera object constructor.
        /// </summary>
        /// <param name="name">Object name.</param>
        /// <param name="enabled">Checks if the camera will affect the drawing matrices.</param>
        /// <param name="pos">Camera position.</param>
        /// <param name="rot">Camera rotation quaternion.</param>
        /// <param name="up">Camera up direction. A normalized vector perpendicular to the surface the camera is standing on.</param>
        /// <param name="fov">FOV in radians. Default is ~65.</param>
        /// <param name="npd">Near plane distance.</param>
        /// <param name="fpd">Far plane distance.</param>
        /// <param name="allow2d">Toggles drawing 2D elements like Sprites and TextPrints</param>
        public Camera(string name = "Name",bool enabled = true,Vector3 pos=default,Vector3 rot=default,Vector3 up=default,float fov= 1.1344f, float npd = 0.01f,float fpd = 500f,bool allow2d = true)
        {
            Name = name;
            Enabled = enabled;
            Position = pos;
            Rotation = Quaternion.CreateFromYawPitchRoll(rot.Y,rot.X,rot.Z);
            FOV = fov;
            NearPlaneDistance = npd;
            FarPlaneDistance = fpd;
            Up = up;
            LookAtLocation = false;
            Allow2DSprites = allow2d;
        }

        /// <summary>
        /// Camera up director. A normalized vector perpendicular to the surface the camera is standing on.
        /// </summary>
        public Vector3 Up;
        /// <summary>
        /// Field of view in radians.
        /// </summary>
        public float FOV;

        /// <summary>
        /// Minimum drawing distance.
        /// </summary>
        public float NearPlaneDistance;

        /// <summary>
        /// Maximum drawing distance.
        /// </summary>
        public float FarPlaneDistance;

        /// <summary>
        /// Makes the camera object look at a specific point rather than using a rotation.
        /// </summary>
        public bool LookAtLocation;

        /// <summary>
        /// Toggles 2D elements like sprites, textprints, etc
        /// </summary>
        public bool Allow2DSprites;

        /// <summary>
        /// Camera look-at position.
        /// </summary>
        public Vector3 Target
        {
            get
            {
                if (LookAtLocation == false) return Position + Vector3.Transform(Vector3.UnitZ, Matrix.CreateFromQuaternion(Rotation));
                else return _target;
            }
            set
            {
                if (LookAtLocation) _target = value;
                else throw new InvalidOperationException("Cannot set the camera target location when the camera is using a quaternion.");
            }
        }
        Vector3 _target;
        /// <summary>
        /// Camera View Matrix.
        /// </summary>
        public Matrix View
        {
            get
            {
                if (!LookAtLocation) return Matrix.CreateLookAt(Position, Target, Up);
                else return Matrix.CreateLookAt(Position, _target, Up);
            }
        }
        /// <summary>
        /// Camera projection Matrix.
        /// </summary>
        public Matrix Projection
        {
            get
            {
                return Matrix.CreatePerspectiveFieldOfView(FOV, CurrentProject.Resolution.X / CurrentProject.Resolution.Y , NearPlaneDistance, FarPlaneDistance);
            }
        }
        /// <summary>
        /// Bounding frustrum generated by the camera object.
        /// </summary>
        public BoundingFrustum CameraFrustum
        {
            get
            {
                return new BoundingFrustum(View * Projection);
            }
        }
        /// <summary>
        /// Affects the drawing matrices.
        /// </summary>
        /// <param name="time">Not used.</param>
        /// <param name="frustrum">Not used.</param>
        /// <param name="view">Output value.</param>
        /// <param name="projection">Output value.</param>
        public override void Draw(GameTime time, BoundingFrustum frustrum, ref Matrix view, ref Matrix projection)
        {
            view = View;
            projection = Projection;
        }
        /// <summary>
        /// Draws the camera marker.
        /// </summary>
        /// <param name="time">dt</param>
        /// <param name="frustrum">view frustrum</param>
        /// <param name="view">view matrix</param>
        /// <param name="projection">projection matrix</param>
        public override void EditorDraw(GameTime time, BoundingFrustum frustrum, ref Matrix view, ref Matrix projection)
        {
            if(frustrum.Contains(new BoundingSphere(Position,1)) != ContainmentType.Disjoint)
            {
                CameraModel.Draw(World, view, projection);
            }
        }
        /// <summary>
        /// Editor only. Represents the Camera marker model.
        /// </summary>
        public static Model CameraModel;

        /// <summary>
        /// Represents the translation matrix.
        /// </summary>
        public new Matrix World
        {
            get
            {
                return Matrix.CreateFromYawPitchRoll(RotationEuler.Y, RotationEuler.X, RotationEuler.Z) * Matrix.CreateTranslation(Position);
            }
        }
        /// <summary>
        /// Function used inside the file I/O system.
        /// </summary>
        /// <param name="buff">Byte buffer</param>
        /// <param name="position">Byte position</param>
        /// <param name="result">Resulting Camera Object</param>
        public override void LoadF(byte[] buff, ref int position, out IGameObject result)
        {
            string name = ByteCodeParser.GetString(buff,ref position);

            bool enabled = ByteCodeParser.GetBool(buff, ref position);
            Vector3 pos = ByteCodeParser.GetVector3(buff,ref position);
            Vector3 rot = ByteCodeParser.GetVector3(buff, ref position);
            Vector3 up = ByteCodeParser.GetVector3(buff, ref position);
            Vector3 d1 = ByteCodeParser.GetVector3(buff, ref position);
            bool allow2d = ByteCodeParser.GetBool(buff, ref position);
            result = new Camera(name,enabled,pos,rot,up,d1.X,d1.Y,d1.Z,allow2d);
        }
        /// <summary>
        /// Function used inside the file I/O system
        /// </summary>
        /// <param name="buff"></param>
        public override void SaveF(List<byte> buff)
        {
            ByteCodeParser.SetString(buff,Name);
            ByteCodeParser.SetBool(buff, Enabled);
            ByteCodeParser.SetVector3(buff, Position);
            ByteCodeParser.SetVector3(buff, RotationEuler);
            ByteCodeParser.SetVector3(buff, Up);
            ByteCodeParser.SetVector3(buff, new Vector3(FOV, NearPlaneDistance, FarPlaneDistance));
            ByteCodeParser.SetBool(buff, Allow2DSprites);
        }
    }
}
